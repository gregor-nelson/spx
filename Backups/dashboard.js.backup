// =============================================================================
// SPX Options Monitor - Dashboard JavaScript (IBKR Theme)
// =============================================================================

// Theme colors matching CSS variables (IBKR Dark Theme - exact values)
const theme = {
    // IBKR Neutral backgrounds
    neutral0: '#16171f',      // hsla(220, 17%, 10%)
    neutral3: '#1d1f26',      // hsla(220, 13%, 13%)
    neutral5: '#222428',      // hsla(217, 11%, 15%)
    neutral10: '#2f3138',     // hsla(225, 8%, 20%)
    neutral20: '#434650',     // hsla(223, 5%, 28%)
    neutral30: '#575a62',     // hsla(220, 5%, 36%)
    // Background aliases
    bgBody: '#16161f',        // hsla(240, 17%, 10%)
    bgBodyLight: '#222a3a',   // hsla(221, 22%, 17%)
    bgDarkest: '#16171f',
    bgPrimary: '#16161f',
    bgSecondary: '#222a3a',
    bgTertiary: '#2f3138',
    bgHover: '#434650',
    // Borders
    border: '#484a57',        // hsla(240, 7%, 30%)
    borderLight: '#575a62',
    // IBKR Text colors
    fontColor: '#d6d6d6',     // hsla(0, 0%, 84%)
    fontColorLight: '#b8b8b8', // hsla(0, 0%, 72%)
    fontColorDark: '#ffffff',
    thColor: '#6b7684',       // hsla(208, 7%, 46%)
    // Aliases
    textPrimary: '#d6d6d6',
    textSecondary: '#b8b8b8',
    textMuted: '#6b7684',
    textHeading: '#ffffff',
    // IBKR Primary (Brand Red)
    primary: '#da1b2c',       // hsla(355, 85%, 46%)
    primaryHover: '#e5394a',  // hsla(355, 85%, 51%)
    primaryActive: '#eb5765', // hsla(355, 85%, 56%)
    // IBKR Semantic Colors
    info: '#3b82f6',          // hsla(216, 88%, 57%)
    success: '#0fb359',       // hsla(148, 85%, 38%)
    warning: '#ffaa00',       // hsla(42, 100%, 50%)
    danger: '#ff334d',        // hsla(355, 100%, 60%)
    // Legacy aliases
    accentBrand: '#da1b2c',
    accentBlue: '#3b82f6',
    accentGreen: '#0fb359',
    accentRed: '#ff334d',
    accentOrange: '#ffaa00',
    accentPurple: '#a855f7'
};

// Plotly dark theme layout (IBKR Style - refined)
const plotlyLayout = {
    paper_bgcolor: theme.bgSecondary,
    plot_bgcolor: theme.bgSecondary,
    font: {
        color: theme.fontColor,
        family: "'Source Sans Pro', 'Proxima Nova', Arial, sans-serif",
        size: 12
    },
    // IBKR-styled tooltip/hoverlabel - refined with subtle shadow effect
    hoverlabel: {
        bgcolor: theme.neutral5,
        bordercolor: theme.neutral30,
        font: {
            family: "'Source Sans Pro', 'Proxima Nova', Arial, sans-serif",
            size: 12,
            color: theme.fontColor
        },
        align: 'left',
        namelength: -1  // Show full trace name
    },
    // Title styling
    title: {
        font: {
            family: "'Source Sans Pro', 'Proxima Nova', Arial, sans-serif",
            size: 13,
            color: theme.textSecondary
        },
        x: 0,
        xanchor: 'left',
        y: 0.98,
        yanchor: 'top'
    },
    // Legend styling - compact IBKR style
    legend: {
        bgcolor: 'rgba(0,0,0,0)',
        bordercolor: theme.border,
        borderwidth: 0,
        font: {
            family: "'Source Sans Pro', 'Proxima Nova', Arial, sans-serif",
            size: 10,
            color: theme.textMuted
        },
        orientation: 'h',
        x: 0,
        y: -0.12,
        tracegroupgap: 8
    },
    xaxis: {
        // IBKR: Very subtle grids, almost invisible
        gridcolor: 'rgba(72, 74, 87, 0.3)',  // theme.border at 30% opacity
        gridwidth: 0.5,
        showgrid: true,
        // Axis line more prominent than grid
        linecolor: theme.border,
        linewidth: 1,
        showline: true,
        // Zero line styling
        zerolinecolor: theme.neutral30,
        zerolinewidth: 1,
        // Ticks - small outside ticks like IBKR TWS
        ticks: 'outside',
        ticklen: 3,
        tickwidth: 1,
        tickcolor: theme.border,
        tickfont: {
            family: "'Source Sans Pro', 'Proxima Nova', Arial, sans-serif",
            size: 10,
            color: theme.textMuted
        },
        title: {
            font: {
                family: "'Source Sans Pro', 'Proxima Nova', Arial, sans-serif",
                size: 11,
                color: theme.textMuted
            },
            standoff: 8
        },
        // Crosshair spike line
        showspikes: true,
        spikecolor: theme.neutral30,
        spikethickness: 1,
        spikedash: 'dot',
        spikemode: 'across'
    },
    yaxis: {
        // IBKR: Very subtle grids
        gridcolor: 'rgba(72, 74, 87, 0.3)',
        gridwidth: 0.5,
        showgrid: true,
        // Axis line
        linecolor: theme.border,
        linewidth: 1,
        showline: true,
        // Zero line
        zerolinecolor: theme.neutral30,
        zerolinewidth: 1,
        // Ticks
        ticks: 'outside',
        ticklen: 3,
        tickwidth: 1,
        tickcolor: theme.border,
        tickfont: {
            family: "'Source Sans Pro', 'Proxima Nova', Arial, sans-serif",
            size: 10,
            color: theme.textMuted
        },
        title: {
            font: {
                family: "'Source Sans Pro', 'Proxima Nova', Arial, sans-serif",
                size: 11,
                color: theme.textMuted
            },
            standoff: 8
        },
        // Crosshair spike line
        showspikes: true,
        spikecolor: theme.neutral30,
        spikethickness: 1,
        spikedash: 'dot',
        spikemode: 'across'
    },
    margin: { t: 32, r: 12, b: 38, l: 48 },
    // Crosshair settings
    hovermode: 'closest',
    spikedistance: -1
};

const plotlyConfig = {
    responsive: true,
    displayModeBar: false
};

// Sidebar state
let sidebarCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';

function toggleSidebar() {
    sidebarCollapsed = !sidebarCollapsed;
    localStorage.setItem('sidebarCollapsed', sidebarCollapsed);
    applySidebarState();
}

function applySidebarState() {
    const terminal = document.getElementById('terminal');
    const toggleIcon = document.getElementById('toggleIcon');

    if (sidebarCollapsed) {
        terminal.classList.add('sidebar-collapsed');
        toggleIcon.className = 'ph ph-caret-right';
    } else {
        terminal.classList.remove('sidebar-collapsed');
        toggleIcon.className = 'ph ph-caret-left';
    }

    // Trigger Plotly resize after transition
    setTimeout(() => {
        window.dispatchEvent(new Event('resize'));
    }, 200);
}

// Detail panel state
let detailCollapsed = localStorage.getItem('detailCollapsed') === 'true';

function toggleDetailPanel() {
    detailCollapsed = !detailCollapsed;
    localStorage.setItem('detailCollapsed', detailCollapsed);
    applyDetailPanelState();
}

function applyDetailPanelState() {
    const terminal = document.getElementById('terminal');
    const toggleIcon = document.getElementById('detailToggleIcon');

    if (detailCollapsed) {
        terminal.classList.add('detail-collapsed');
        toggleIcon.className = 'ph ph-caret-left';
    } else {
        terminal.classList.remove('detail-collapsed');
        toggleIcon.className = 'ph ph-caret-right';
    }

    // Trigger Plotly resize after transition
    setTimeout(() => {
        window.dispatchEvent(new Event('resize'));
    }, 200);
}

// Initialize panel states on load
document.addEventListener('DOMContentLoaded', () => {
    applySidebarState();
    applyDetailPanelState();
    updateToolbarTime();
    setInterval(updateToolbarTime, 1000);
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
    // Ctrl+B to toggle left sidebar
    if (e.ctrlKey && e.key === 'b') {
        e.preventDefault();
        toggleSidebar();
    }
    // Ctrl+] to toggle right panel
    if (e.ctrlKey && e.key === ']') {
        e.preventDefault();
        toggleDetailPanel();
    }
});

function updateToolbarTime() {
    const timeEl = document.getElementById('toolbarTime');
    if (timeEl) {
        const now = new Date();
        timeEl.textContent = now.toLocaleTimeString('en-US', {
            hour: '2-digit',
            minute: '2-digit',
            hour12: false
        });
    }
}

function updateToolbarStats(meta, stats) {
    const spxEl = document.getElementById('toolbarSpx');
    const contractsEl = document.getElementById('toolbarContracts');
    const flaggedEl = document.getElementById('toolbarFlagged');
    const pollsEl = document.getElementById('toolbarPolls');
    const alertsEl = document.getElementById('toolbarAlerts');

    if (spxEl && meta.spot_price) {
        spxEl.textContent = meta.spot_price.toLocaleString();
    }
    if (contractsEl && meta.contracts_count) {
        contractsEl.textContent = meta.contracts_count;
    }
    if (flaggedEl) {
        const flagged = meta.contracts_with_flags || 0;
        flaggedEl.textContent = flagged;
        flaggedEl.className = 'stat-value' + (flagged > 0 ? ' negative' : '');
    }
    if (pollsEl && stats) {
        pollsEl.textContent = stats.intraday?.poll_count || 0;
    }
    if (alertsEl && stats) {
        const alertCount = stats.alert_count || 0;
        alertsEl.textContent = alertCount;
        alertsEl.className = 'stat-value' + (alertCount > 0 ? ' negative' : '');
    }
}

let currentTab = 'charts';
let selectedExpiration = '';
let moversSortBy = 'volume';  // 'volume', 'oi', 'delta', 'notional'
let comparisonMode = 'hour';
let data = {
    enriched: { data: [], meta: {} },
    latest: [],
    intraday: [],
    daily: [],
    alerts: [],
    expirations: { intraday: [], daily: [] }
};

async function fetchJSON(url) {
    const res = await fetch(url);
    return res.json();
}

async function loadExpirations() {
    try {
        data.expirations = await fetchJSON('/api/expirations');
        updateExpirationDropdown();
    } catch (e) {
        console.error('Failed to load expirations:', e);
    }
}

function updateExpirationDropdown() {
    const select = document.getElementById('expirationFilter');
    const exps = data.expirations.intraday;
    const currentValue = select.value;

    select.innerHTML = '<option value="">All</option>';

    for (const exp of exps) {
        const opt = document.createElement('option');
        opt.value = exp.expiration;
        opt.textContent = `${exp.expiration} (${exp.dte}d)`;
        select.appendChild(opt);
    }

    if (currentValue && [...select.options].some(o => o.value === currentValue)) {
        select.value = currentValue;
    }

    document.getElementById('statExpirations').textContent = exps.length;
}

function onExpirationChange() {
    selectedExpiration = document.getElementById('expirationFilter').value;
    loadData();
}

let cachedStats = null;

async function loadStats() {
    try {
        const stats = await fetchJSON('/api/stats');
        cachedStats = stats;
        document.getElementById('statPolls').textContent = stats.intraday.poll_count || 0;
        document.getElementById('statContracts').textContent = stats.intraday.unique_contracts || 0;
        document.getElementById('statDbSize').textContent = stats.db_size_mb + ' MB';

        // Update toolbar
        document.getElementById('toolbarPolls').textContent = stats.intraday.poll_count || 0;
        const alertCount = stats.alert_count || 0;
        const alertsEl = document.getElementById('toolbarAlerts');
        alertsEl.textContent = alertCount;
        alertsEl.className = 'stat-value' + (alertCount > 0 ? ' negative' : '');
    } catch (e) {
        console.error('Failed to load stats:', e);
    }
}

async function loadData() {
    const expParam = selectedExpiration ? `?expiration=${selectedExpiration}` : '';

    try {
        const [enriched, latest, intraday, daily, alerts] = await Promise.all([
            fetchJSON('/api/intraday/latest/enriched' + expParam),
            fetchJSON('/api/intraday/latest' + expParam),
            fetchJSON('/api/intraday' + expParam),
            fetchJSON('/api/daily' + expParam),
            fetchJSON('/api/alerts')
        ]);

        data.enriched = enriched;
        data.latest = latest;
        data.intraday = intraday;
        data.daily = daily;
        data.alerts = alerts;

        // Update toolbar with enriched meta
        const meta = enriched.meta || {};
        const spxEl = document.getElementById('toolbarSpx');
        const contractsEl = document.getElementById('toolbarContracts');
        const flaggedEl = document.getElementById('toolbarFlagged');

        if (spxEl) {
            spxEl.textContent = meta.spot_price ? meta.spot_price.toLocaleString() : '-';
        }
        if (contractsEl) {
            contractsEl.textContent = meta.contracts_count || '-';
        }
        if (flaggedEl) {
            const flagged = meta.contracts_with_flags || 0;
            flaggedEl.textContent = flagged;
            flaggedEl.className = 'stat-value' + (flagged > 0 ? ' negative' : '');
        }

        renderTab();
        renderMoversPanel();
    } catch (e) {
        console.error('Failed to load data:', e);
        document.getElementById('content').innerHTML =
            '<div class="loading">Error loading data. Is the server running?</div>';
    }
}

async function loadAll() {
    document.getElementById('lastUpdated').textContent = 'Loading...';

    await loadExpirations();
    await loadStats();
    await loadData();

    document.getElementById('lastUpdated').textContent = new Date().toLocaleTimeString();
}

function showTab(tab) {
    currentTab = tab;
    document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
    // Use closest to handle clicks on child elements (icon, text)
    const clickedTab = event.target.closest('.nav-tab');
    if (clickedTab) {
        clickedTab.classList.add('active');
    }
    renderTab();
}

function renderTab() {
    const content = document.getElementById('content');

    switch (currentTab) {
        case 'charts':
            content.innerHTML = renderCharts();
            renderPlotlyCharts();
            break;
        case 'greeks':
            content.innerHTML = renderGreeksTab();
            renderGreeksCharts();
            break;
        case 'latest':
            content.innerHTML = renderSnapshotTable(data.latest, true);
            break;
        case 'intraday':
            content.innerHTML = renderSnapshotTable(data.intraday, true);
            break;
        case 'daily':
            content.innerHTML = renderDailyTable(data.daily);
            break;
        case 'alerts':
            content.innerHTML = renderAlertsTable(data.alerts);
            break;
    }
}

function renderCharts() {
    const meta = data.enriched.meta || {};
    const hasYesterdayData = meta.yesterday_hour_source || meta.yesterday_eod_source;

    return `
        <div class="meta-bar">
            <div class="meta-item">
                <span class="meta-label">Last Update</span>
                <span class="meta-value">${meta.captured_at ? meta.captured_at.substring(11, 16) : '-'}</span>
            </div>
            <div class="meta-item">
                <span class="meta-label">Exp Filter</span>
                <span class="meta-value">${selectedExpiration || 'All'}</span>
            </div>
            <div class="meta-item">
                <span class="meta-label">Yesterday Data</span>
                <span class="meta-value ${hasYesterdayData ? 'positive' : 'warning'}">${hasYesterdayData ? 'Available' : 'None'}</span>
            </div>
        </div>

        <div class="chart-container chart-full">
            <div id="heatmapChart" style="height: 320px;"></div>
        </div>
        <div class="chart-grid">
            <div class="chart-container">
                <div id="volumeByStrikeChart" style="height: 320px;"></div>
            </div>
            <div class="chart-container">
                <div id="oiByStrikeChart" style="height: 320px;"></div>
            </div>
        </div>
        <div class="chart-grid">
            <div class="chart-container">
                <div id="changeHeatmapChart" style="height: 320px;"></div>
            </div>
            <div class="chart-container">
                <div id="volumeTimeChart" style="height: 320px;"></div>
            </div>
        </div>
    `;
}

function setComparisonMode(mode) {
    comparisonMode = mode;

    // Update toggle buttons
    document.querySelectorAll('.comparison-toggle .toggle-btn').forEach(btn => {
        btn.classList.toggle('active', btn.textContent === (mode === 'hour' ? '1H' : 'EOD'));
    });

    renderMoversPanel();
    if (currentTab === 'charts') {
        renderPlotlyCharts();
    }
}

function setSortBy(type) {
    moversSortBy = type;  // 'volume', 'oi', 'delta', 'notional'

    // Update sort buttons
    document.querySelectorAll('.sort-controls .sort-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.sort === type);
    });

    renderMoversPanel();
}

function renderMoversPanel() {
    const container = document.getElementById('moversList');
    if (!container) return;

    const enrichedData = data.enriched.data || [];
    if (!enrichedData.length) {
        container.innerHTML = '<div class="no-data">No data</div>';
        return;
    }

    const suffix = comparisonMode === 'hour' ? '_hour' : '_eod';

    // Determine sort field and get value for each row
    const getSortValue = (r) => {
        switch (moversSortBy) {
            case 'volume': return r.volume_today || 0;
            case 'oi': return r.open_interest || 0;
            case 'delta': return r['volume_delta' + suffix] || 0;
            case 'notional': return r.notional_today || 0;
            default: return r.volume_today || 0;
        }
    };

    // Get column header based on sort
    const getColumnHeader = () => {
        switch (moversSortBy) {
            case 'volume': return 'VOL';
            case 'oi': return 'OI';
            case 'delta': return 'Δ VOL';
            case 'notional': return 'NOTIONAL';
            default: return 'VOL';
        }
    };

    // Format value based on sort type
    const formatValue = (r) => {
        switch (moversSortBy) {
            case 'volume':
                return (r.volume_today || 0).toLocaleString();
            case 'oi':
                return (r.open_interest || 0).toLocaleString();
            case 'delta':
                const delta = r['volume_delta' + suffix] || 0;
                return (delta > 0 ? '+' : '') + delta.toLocaleString();
            case 'notional':
                const notional = r.notional_today || 0;
                return notional >= 1000000
                    ? `$${(notional / 1000000).toFixed(1)}M`
                    : `$${(notional / 1000).toFixed(0)}K`;
            default:
                return (r.volume_today || 0).toLocaleString();
        }
    };

    // Get value class for coloring
    const getValueClass = (r) => {
        if (moversSortBy === 'delta') {
            const delta = r['volume_delta' + suffix] || 0;
            return delta > 0 ? 'positive' : (delta < 0 ? 'negative' : '');
        }
        return '';
    };

    const sorted = [...enrichedData]
        .filter(r => {
            const val = getSortValue(r);
            return val !== null && val !== undefined && val > 0;
        })
        .sort((a, b) => getSortValue(b) - getSortValue(a))
        .slice(0, 10);

    if (!sorted.length) {
        container.innerHTML = '<div class="no-data">No movers detected</div>';
        return;
    }

    // Build table header
    const headerHtml = `
        <div class="movers-table-header">
            <span>STRIKE</span>
            <span>DTE</span>
            <span style="text-align:right">${getColumnHeader()}</span>
            <span></span>
        </div>
    `;

    // Build table rows
    const rowsHtml = sorted.map(r => {
        const hasFlags = r.flags && r.flags.length > 0;
        const flagsHtml = hasFlags
            ? r.flags.map(f => `<span class="flag ${f}">${f.charAt(0).toUpperCase()}</span>`).join('')
            : '';

        return `
            <div class="mover-row ${hasFlags ? 'has-flags' : ''}">
                <span class="mover-strike">${r.strike}</span>
                <span class="mover-dte">${r.dte}d</span>
                <span class="mover-value ${getValueClass(r)}">${formatValue(r)}</span>
                <span class="mover-flags">${flagsHtml}</span>
            </div>
        `;
    }).join('');

    container.innerHTML = headerHtml + `<div class="movers-table-body">${rowsHtml}</div>`;
}

function renderPlotlyCharts() {
    const enrichedData = data.enriched.data || [];

    if (!enrichedData.length && !data.latest.length) {
        document.getElementById('volumeByStrikeChart').innerHTML = '<div class="loading">No data available</div>';
        return;
    }

    const chartData = enrichedData.length ? enrichedData : data.latest;
    const suffix = comparisonMode === 'hour' ? '_hour' : '_eod';

    // Get spot price for ATM reference line
    const spotPrice = data.enriched.meta?.spot_price;

    // Volume by Strike
    const strikes = chartData.map(r => r.strike);
    const volumes = chartData.map(r => r.volume_today || r.volume_cumulative || 0);

    // Find closest strike to spot price for ATM line
    let atmStrike = null;
    if (spotPrice && strikes.length) {
        atmStrike = strikes.reduce((prev, curr) =>
            Math.abs(curr - spotPrice) < Math.abs(prev - spotPrice) ? curr : prev
        );
    }

    // ATM reference line shape
    const atmShapes = atmStrike ? [{
        type: 'line',
        x0: atmStrike,
        x1: atmStrike,
        y0: 0,
        y1: 1,
        yref: 'paper',
        line: {
            color: theme.primary,
            width: 2,
            dash: 'dash'
        }
    }] : [];

    // ATM annotation
    const atmAnnotations = atmStrike ? [{
        x: atmStrike,
        y: 1,
        yref: 'paper',
        text: `ATM ${spotPrice?.toLocaleString() || ''}`,
        showarrow: false,
        font: {
            family: "'Source Sans Pro', Arial",
            size: 10,
            color: theme.primary
        },
        yanchor: 'bottom',
        yshift: 4
    }] : [];

    // IBKR-style muted color palette for bar charts
    const colors = chartData.map(r => {
        const pctChange = r['volume_pct_change' + suffix];
        if (pctChange === null || pctChange === undefined) return theme.neutral30;
        if (pctChange > 100) return '#b33a3a';       // Muted red
        if (pctChange > 50) return '#b87a14';        // Muted amber
        if (pctChange > 0) return '#2a8a5a';         // Muted green
        if (pctChange < 0) return '#3b72a8';         // Muted blue
        return theme.neutral30;
    });

    const hoverTexts = chartData.map(r => {
        const vol = r.volume_today || r.volume_cumulative || 0;
        const delta = r['volume_delta' + suffix] || 0;
        const pct = r['volume_pct_change' + suffix];
        const pctStr = pct !== null ? ` (${pct > 0 ? '+' : ''}${pct.toFixed(1)}%)` : '';
        return `Strike: ${r.strike}<br>Volume: ${vol.toLocaleString()}<br>Δ: ${delta > 0 ? '+' : ''}${delta.toLocaleString()}${pctStr}`;
    });

    Plotly.newPlot('volumeByStrikeChart', [{
        x: strikes,
        y: volumes,
        type: 'bar',
        marker: {
            color: colors,
            line: { color: 'rgba(0,0,0,0)', width: 0 }  // No border on bars
        },
        hovertemplate: '%{text}<extra></extra>',
        text: hoverTexts,
        hoverlabel: {
            bgcolor: theme.neutral5,
            bordercolor: theme.neutral30,
            font: { family: "'Source Sans Pro', Arial", size: 12, color: theme.fontColor }
        }
    }], {
        ...plotlyLayout,
        title: { text: 'Volume by Strike', font: { size: 13, color: theme.textSecondary }, x: 0, xanchor: 'left' },
        xaxis: {
            ...plotlyLayout.xaxis,
            title: { text: 'Strike', font: { size: 11, color: theme.textMuted }, standoff: 6 }
        },
        yaxis: {
            ...plotlyLayout.yaxis,
            title: { text: 'Volume', font: { size: 11, color: theme.textMuted }, standoff: 6 }
        },
        bargap: 0.12,
        shapes: atmShapes,
        annotations: atmAnnotations
    }, {
        ...plotlyConfig,
        displayModeBar: true,
        modeBarButtonsToRemove: ['lasso2d', 'select2d', 'autoScale2d'],
        displaylogo: false
    });

    // OI by Strike - IBKR-style muted palette
    const ois = chartData.map(r => r.open_interest || 0);
    const oiColors = chartData.map(r => {
        const oiPct = r.oi_pct_change;
        if (oiPct === null || oiPct === undefined) return '#7a5aaa';  // Muted purple
        if (oiPct > 5) return '#2a8a5a';   // Muted green
        if (oiPct < -5) return '#b33a3a';  // Muted red
        return '#7a5aaa';  // Muted purple (neutral OI change)
    });

    const oiHoverTexts = chartData.map(r => {
        const oi = r.open_interest || 0;
        const delta = r.oi_delta;
        const pct = r.oi_pct_change;
        let deltaStr = '';
        if (delta !== null) {
            deltaStr = `<br>Δ: ${delta > 0 ? '+' : ''}${delta.toLocaleString()}`;
            if (pct !== null) deltaStr += ` (${pct > 0 ? '+' : ''}${pct.toFixed(1)}%)`;
        }
        return `Strike: ${r.strike}<br>OI: ${oi.toLocaleString()}${deltaStr}`;
    });

    Plotly.newPlot('oiByStrikeChart', [{
        x: strikes,
        y: ois,
        type: 'bar',
        marker: {
            color: oiColors,
            line: { color: 'rgba(0,0,0,0)', width: 0 }
        },
        hovertemplate: '%{text}<extra></extra>',
        text: oiHoverTexts,
        hoverlabel: {
            bgcolor: theme.neutral5,
            bordercolor: theme.neutral30,
            font: { family: "'Source Sans Pro', Arial", size: 12, color: theme.fontColor }
        }
    }], {
        ...plotlyLayout,
        title: { text: 'Open Interest by Strike', font: { size: 13, color: theme.textSecondary }, x: 0, xanchor: 'left' },
        xaxis: {
            ...plotlyLayout.xaxis,
            title: { text: 'Strike', font: { size: 11, color: theme.textMuted }, standoff: 6 }
        },
        yaxis: {
            ...plotlyLayout.yaxis,
            title: { text: 'Open Interest', font: { size: 11, color: theme.textMuted }, standoff: 6 }
        },
        bargap: 0.12,
        shapes: atmShapes,
        annotations: atmAnnotations
    }, {
        ...plotlyConfig,
        displayModeBar: true,
        modeBarButtonsToRemove: ['lasso2d', 'select2d', 'autoScale2d'],
        displaylogo: false
    });

    renderHeatmap();
    renderChangeHeatmap();
    renderVolumeTimeSeries();
}

function renderHeatmap() {
    const enrichedData = data.enriched.data || [];
    const allData = enrichedData.length ? enrichedData : (data.latest.length ? data.latest : data.intraday);

    if (!allData.length) {
        document.getElementById('heatmapChart').innerHTML = '<div class="loading">No data</div>';
        return;
    }

    const expirations = [...new Set(allData.map(r => r.expiration))].sort();
    const strikes = [...new Set(allData.map(r => r.strike))].sort((a, b) => a - b);

    const z = [];
    const hoverText = [];

    for (const exp of expirations) {
        const row = [];
        const hoverRow = [];
        for (const strike of strikes) {
            const match = allData.find(r => r.expiration === exp && r.strike === strike);
            const vol = match ? (match.volume_today || match.volume_cumulative || 0) : 0;
            const notional = match ? (match.notional_today || 0) : 0;
            row.push(vol > 0 ? Math.log10(vol + 1) : 0);
            hoverRow.push(`${exp}<br>Strike: ${strike}<br>Vol: ${vol.toLocaleString()}<br>$${notional.toLocaleString()}`);
        }
        z.push(row);
        hoverText.push(hoverRow);
    }

    // IBKR-style muted colorscale - professional, data-dense appearance
    const volumeColorscale = [
        [0, theme.neutral5],           // Empty cells - nearly invisible
        [0.1, theme.neutral10],        // Very low volume
        [0.25, '#1e3a5f'],             // Muted blue transition
        [0.4, '#2563a8'],              // Medium blue
        [0.55, theme.info],            // Info blue
        [0.7, '#b87a14'],              // Muted amber
        [0.85, theme.warning],         // Warning amber
        [1, '#c45a28']                 // Muted red-orange (less harsh than danger)
    ];

    // Limit x-axis ticks - show ~15-20 strikes max for readability
    const maxTicks = 18;
    const tickStep = Math.ceil(strikes.length / maxTicks);
    const tickVals = strikes.filter((_, i) => i % tickStep === 0);

    // Format expiration dates as "3rd Dec" style
    const expLabels = expirations.map(formatShortDate);

    Plotly.newPlot('heatmapChart', [{
        z: z,
        x: strikes,
        y: expirations,
        type: 'heatmap',
        colorscale: volumeColorscale,
        hoverinfo: 'text',
        text: hoverText,
        xgap: 1,  // Subtle cell separation
        ygap: 1,
        colorbar: {
            title: {
                text: 'Vol (log)',
                font: { family: "'Source Sans Pro', Arial", size: 9, color: theme.textMuted },
                side: 'right'
            },
            tickfont: { family: "'Source Sans Pro', Arial", size: 8, color: theme.textMuted },
            len: 0.75,
            thickness: 8,
            bgcolor: 'rgba(0,0,0,0)',
            bordercolor: 'rgba(0,0,0,0)',
            borderwidth: 0,
            outlinecolor: theme.border,
            outlinewidth: 1,
            xpad: 6,
            ticklen: 3
        },
        hoverlabel: {
            bgcolor: theme.neutral5,
            bordercolor: theme.neutral30,
            font: { family: "'Source Sans Pro', Arial", size: 12, color: theme.fontColor }
        }
    }], {
        ...plotlyLayout,
        title: { text: 'Volume Surface', font: { size: 13, color: theme.textSecondary }, x: 0, xanchor: 'left' },
        xaxis: {
            ...plotlyLayout.xaxis,
            title: { text: 'Strike', font: { size: 11, color: theme.textMuted }, standoff: 6 },
            type: 'category',
            showgrid: false,
            tickmode: 'array',
            tickvals: tickVals,
            ticktext: tickVals.map(String)
        },
        yaxis: {
            ...plotlyLayout.yaxis,
            title: '',
            type: 'category',
            showgrid: false,
            tickmode: 'array',
            tickvals: expirations,
            ticktext: expLabels
        }
    }, plotlyConfig);
}

function renderChangeHeatmap() {
    const enrichedData = data.enriched.data || [];
    const suffix = comparisonMode === 'hour' ? '_hour' : '_eod';

    if (!enrichedData.length) {
        document.getElementById('changeHeatmapChart').innerHTML = '<div class="loading">No data</div>';
        return;
    }

    const expirations = [...new Set(enrichedData.map(r => r.expiration))].sort();
    const strikes = [...new Set(enrichedData.map(r => r.strike))].sort((a, b) => a - b);

    const z = [];
    const hoverText = [];

    for (const exp of expirations) {
        const row = [];
        const hoverRow = [];
        for (const strike of strikes) {
            const match = enrichedData.find(r => r.expiration === exp && r.strike === strike);
            const pctChange = match ? match['volume_pct_change' + suffix] : null;
            const volDelta = match ? match['volume_delta' + suffix] : 0;

            let zVal = 0;
            if (pctChange !== null) {
                zVal = Math.max(-100, Math.min(200, pctChange));
            }
            row.push(zVal);

            const pctStr = pctChange !== null ? `${pctChange > 0 ? '+' : ''}${pctChange.toFixed(1)}%` : '-';
            hoverRow.push(`${exp}<br>Strike: ${strike}<br>Δ: ${pctStr}<br>Vol: ${volDelta > 0 ? '+' : ''}${volDelta.toLocaleString()}`);
        }
        z.push(row);
        hoverText.push(hoverRow);
    }

    // IBKR-style diverging colorscale: blue (negative) -> neutral -> red (positive)
    // More muted than raw semantic colors for professional appearance
    const changeColorscale = [
        [0, '#1e5a9e'],               // Deep blue (very negative)
        [0.25, '#3b82c4'],            // Medium blue
        [0.4, '#4a6a85'],             // Muted blue-gray
        [0.5, theme.neutral10],       // Neutral center
        [0.6, '#7a6045'],             // Muted amber-gray
        [0.75, '#b87a14'],            // Amber
        [0.9, '#c45a28'],             // Orange-red
        [1, '#b33a3a']                // Muted red (very positive)
    ];

    // Limit x-axis ticks for readability
    const maxTicks = 18;
    const tickStep = Math.ceil(strikes.length / maxTicks);
    const tickVals = strikes.filter((_, i) => i % tickStep === 0);

    // Format expiration dates as "3rd Dec" style
    const expLabels = expirations.map(formatShortDate);

    Plotly.newPlot('changeHeatmapChart', [{
        z: z,
        x: strikes,
        y: expirations,
        type: 'heatmap',
        colorscale: changeColorscale,
        zmid: 0,
        hoverinfo: 'text',
        text: hoverText,
        xgap: 1,
        ygap: 1,
        colorbar: {
            title: {
                text: '% Chg',
                font: { family: "'Source Sans Pro', Arial", size: 9, color: theme.textMuted },
                side: 'right'
            },
            tickfont: { family: "'Source Sans Pro', Arial", size: 8, color: theme.textMuted },
            ticksuffix: '%',
            len: 0.75,
            thickness: 8,
            bgcolor: 'rgba(0,0,0,0)',
            bordercolor: 'rgba(0,0,0,0)',
            borderwidth: 0,
            outlinecolor: theme.border,
            outlinewidth: 1,
            xpad: 6,
            ticklen: 3
        },
        hoverlabel: {
            bgcolor: theme.neutral5,
            bordercolor: theme.neutral30,
            font: { family: "'Source Sans Pro', Arial", size: 12, color: theme.fontColor }
        }
    }], {
        ...plotlyLayout,
        title: { text: `Volume Change (vs ${comparisonMode === 'hour' ? '1H' : 'EOD'})`, font: { size: 13, color: theme.textSecondary }, x: 0, xanchor: 'left' },
        xaxis: {
            ...plotlyLayout.xaxis,
            title: { text: 'Strike', font: { size: 11, color: theme.textMuted }, standoff: 6 },
            type: 'category',
            showgrid: false,
            tickmode: 'array',
            tickvals: tickVals,
            ticktext: tickVals.map(String)
        },
        yaxis: {
            ...plotlyLayout.yaxis,
            title: '',
            type: 'category',
            showgrid: false,
            tickmode: 'array',
            tickvals: expirations,
            ticktext: expLabels
        }
    }, plotlyConfig);
}

function renderVolumeTimeSeries() {
    const timeGroups = {};

    for (const row of data.intraday) {
        const time = row.captured_at;
        if (!timeGroups[time]) {
            timeGroups[time] = 0;
        }
        timeGroups[time] += row.volume_cumulative || 0;
    }

    const times = Object.keys(timeGroups).sort();
    const totalVolumes = times.map(t => timeGroups[t]);

    if (!times.length) {
        document.getElementById('volumeTimeChart').innerHTML = '<div class="loading">No intraday data</div>';
        return;
    }

    Plotly.newPlot('volumeTimeChart', [{
        x: times.map(t => t.substring(11, 16)),
        y: totalVolumes,
        type: 'scatter',
        mode: 'lines+markers',
        // IBKR style: straight lines, not splines
        line: {
            color: theme.primary,
            width: 1.5,
            shape: 'linear'
        },
        // Smaller, subtler markers
        marker: {
            color: theme.primary,
            size: 4,
            line: { color: theme.bgSecondary, width: 1 }
        },
        hovertemplate: '<b>%{x}</b><br>Volume: %{y:,.0f}<extra></extra>',
        hoverlabel: {
            bgcolor: theme.neutral5,
            bordercolor: theme.neutral30,
            font: { family: "'Source Sans Pro', Arial", size: 12, color: theme.fontColor }
        },
        // Subtle fill under the line
        fill: 'tozeroy',
        fillcolor: 'rgba(218, 27, 44, 0.06)'
    }], {
        ...plotlyLayout,
        title: { text: 'Total Volume Over Time', font: { size: 13, color: theme.textSecondary }, x: 0, xanchor: 'left' },
        xaxis: {
            ...plotlyLayout.xaxis,
            title: { text: 'Time (ET)', font: { size: 11, color: theme.textMuted }, standoff: 6 },
            // Range slider for zooming
            rangeslider: {
                visible: true,
                thickness: 0.08,
                bgcolor: theme.neutral5,
                bordercolor: theme.border,
                borderwidth: 1
            }
        },
        yaxis: {
            ...plotlyLayout.yaxis,
            title: { text: 'Cumulative Volume', font: { size: 11, color: theme.textMuted }, standoff: 6 }
        },
        margin: { t: 32, r: 12, b: 60, l: 48 }  // Extra bottom margin for range slider
    }, plotlyConfig);
}

// Format date as "3rd Dec" style
function formatShortDate(dateStr) {
    if (!dateStr) return dateStr;
    const date = new Date(dateStr + 'T00:00:00');
    const day = date.getDate();
    const month = date.toLocaleString('en-US', { month: 'short' });

    // Add ordinal suffix
    const suffix = (day === 1 || day === 21 || day === 31) ? 'st'
        : (day === 2 || day === 22) ? 'nd'
        : (day === 3 || day === 23) ? 'rd'
        : 'th';

    return `${day}${suffix} ${month}`;
}

function formatNumber(n) {
    if (n === null || n === undefined) return '-';
    return n.toLocaleString();
}

function formatMoney(n) {
    if (n === null || n === undefined) return '-';
    return '$' + n.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
}

function formatPercent(n) {
    if (n === null || n === undefined) return '-';
    return (n * 100).toFixed(1) + '%';
}

function renderSnapshotTable(rows, showExpiration = false) {
    if (!rows.length) {
        return '<div class="loading">No data available</div>';
    }

    let html = `
        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>Time</th>
                        ${showExpiration ? '<th>Exp</th>' : ''}
                        <th>Strike</th>
                        <th>M%</th>
                        <th>DTE</th>
                        <th class="number">Vol</th>
                        <th class="number">Δ</th>
                        <th class="number">OI</th>
                        <th class="number">Price</th>
                        <th class="number">Notional</th>
                        <th class="number">Delta</th>
                        <th class="number">IV</th>
                    </tr>
                </thead>
                <tbody>
    `;

    for (const row of rows) {
        const notional = (row.volume_cumulative || 0) * (row.close_price || 0) * 100;
        const volDeltaClass = row.volume_delta > 0 ? 'positive' : '';

        html += `
            <tr>
                <td>${row.captured_at ? row.captured_at.substring(11, 16) : '-'}</td>
                ${showExpiration ? `<td><span class="exp-badge">${row.expiration || '-'}</span></td>` : ''}
                <td>${row.strike}</td>
                <td class="moneyness">${formatPercent(row.moneyness)}</td>
                <td>${row.dte}</td>
                <td class="number">${formatNumber(row.volume_cumulative)}</td>
                <td class="number ${volDeltaClass}">${row.volume_delta ? '+' + formatNumber(row.volume_delta) : '-'}</td>
                <td class="number">${formatNumber(row.open_interest)}</td>
                <td class="number">${formatMoney(row.close_price)}</td>
                <td class="number">${formatMoney(notional)}</td>
                <td class="number">${row.delta ? row.delta.toFixed(4) : '-'}</td>
                <td class="number">${row.implied_vol ? (row.implied_vol * 100).toFixed(1) + '%' : '-'}</td>
            </tr>
        `;
    }

    html += '</tbody></table></div>';
    return html;
}

function renderDailyTable(rows) {
    if (!rows.length) {
        return '<div class="loading">No daily history</div>';
    }

    let html = `
        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>Date</th>
                        <th>Exp</th>
                        <th>Strike</th>
                        <th>M%</th>
                        <th>DTE</th>
                        <th class="number">Vol</th>
                        <th class="number">OI</th>
                        <th class="number">Close</th>
                        <th class="number">Delta</th>
                        <th class="number">IV</th>
                    </tr>
                </thead>
                <tbody>
    `;

    for (const row of rows) {
        html += `
            <tr>
                <td>${row.trade_date}</td>
                <td><span class="exp-badge">${row.expiration || '-'}</span></td>
                <td>${row.strike}</td>
                <td class="moneyness">${formatPercent(row.moneyness)}</td>
                <td>${row.dte}</td>
                <td class="number">${formatNumber(row.volume)}</td>
                <td class="number">${formatNumber(row.open_interest)}</td>
                <td class="number">${formatMoney(row.close_price)}</td>
                <td class="number">${row.delta ? row.delta.toFixed(4) : '-'}</td>
                <td class="number">${row.implied_vol ? (row.implied_vol * 100).toFixed(1) + '%' : '-'}</td>
            </tr>
        `;
    }

    html += '</tbody></table></div>';
    return html;
}

function renderAlertsTable(rows) {
    if (!rows.length) {
        return '<div class="loading">No alerts</div>';
    }

    let html = `
        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>Time</th>
                        <th>Strike</th>
                        <th>Exp</th>
                        <th class="number">Vol</th>
                        <th class="number">Notional</th>
                        <th>Flags</th>
                    </tr>
                </thead>
                <tbody>
    `;

    for (const row of rows) {
        let flags = '';
        try {
            const reasons = JSON.parse(row.trigger_reasons || '{}');
            if (reasons.flags) {
                flags = reasons.flags.map(f => `<span class="flag ${f}">${f}</span>`).join('');
            }
        } catch (e) {}

        html += `
            <tr class="alert-row">
                <td>${row.triggered_at ? row.triggered_at.substring(0, 16) : '-'}</td>
                <td>${row.strike}</td>
                <td><span class="exp-badge">${row.expiration}</span></td>
                <td class="number">${formatNumber(row.volume_current)}</td>
                <td class="number">${formatMoney(row.premium_notional)}</td>
                <td>${flags}</td>
            </tr>
        `;
    }

    html += '</tbody></table></div>';
    return html;
}

// =============================================================================
// Greeks Tab Functions
// =============================================================================

// Greeks table sorting state
let greeksSortField = 'strike';
let greeksSortAsc = true;

// Vol surface view mode: 'raw' or 'zscore'
let volSurfaceMode = 'raw';

function setVolSurfaceMode(mode) {
    volSurfaceMode = mode;

    // Update toggle buttons
    document.querySelectorAll('.surface-mode-toggle .toggle-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mode === mode);
    });

    renderVolSurfaceChart();
}

function setGreeksSort(field) {
    if (greeksSortField === field) {
        greeksSortAsc = !greeksSortAsc;
    } else {
        greeksSortField = field;
        greeksSortAsc = field === 'strike'; // Default ascending for strike, descending for values
    }
    renderTab();
}

function renderGreeksTab() {
    const enrichedData = data.enriched.data || [];
    const meta = data.enriched.meta || {};

    if (!enrichedData.length) {
        return '<div class="loading">No Greeks data available</div>';
    }

    // Count unique expirations with IV data
    const expsWithIV = [...new Set(enrichedData.filter(r => r.implied_vol !== null).map(r => r.expiration))];

    return `
        <div class="meta-bar">
            <div class="meta-item">
                <span class="meta-label">Last Update</span>
                <span class="meta-value">${meta.captured_at ? meta.captured_at.substring(11, 16) : '-'}</span>
            </div>
            <div class="meta-item">
                <span class="meta-label">Exp Filter</span>
                <span class="meta-value">${selectedExpiration || 'All'}</span>
            </div>
            <div class="meta-item">
                <span class="meta-label">Contracts</span>
                <span class="meta-value">${enrichedData.length}</span>
            </div>
            <div class="meta-item">
                <span class="meta-label">Expirations</span>
                <span class="meta-value">${expsWithIV.length}</span>
            </div>
        </div>

        <div class="greeks-chart-row">
            <div class="chart-container">
                <div id="ivSmileChart" style="height: 320px;"></div>
            </div>
            <div class="chart-container">
                <div class="chart-header">
                    <span class="chart-title">Volatility Surface</span>
                    <div class="surface-mode-toggle">
                        <button class="toggle-btn active" data-mode="raw" onclick="setVolSurfaceMode('raw')" title="Show raw implied volatility values">Raw IV</button>
                        <button class="toggle-btn" data-mode="zscore" onclick="setVolSurfaceMode('zscore')" title="Show Z-scores (standard deviations from mean) to highlight anomalies">Z-Score</button>
                    </div>
                </div>
                <div id="volSurfaceChart" style="height: 290px;"></div>
            </div>
        </div>

        ${renderGreeksTable(enrichedData)}
    `;
}

function renderGreeksTable(rows) {
    if (!rows.length) {
        return '<div class="loading">No data available</div>';
    }

    // Sort the data
    const sorted = [...rows].sort((a, b) => {
        let aVal = a[greeksSortField];
        let bVal = b[greeksSortField];

        // Handle null/undefined values
        if (aVal === null || aVal === undefined) aVal = greeksSortAsc ? Infinity : -Infinity;
        if (bVal === null || bVal === undefined) bVal = greeksSortAsc ? Infinity : -Infinity;

        if (greeksSortAsc) {
            return aVal > bVal ? 1 : aVal < bVal ? -1 : 0;
        } else {
            return aVal < bVal ? 1 : aVal > bVal ? -1 : 0;
        }
    });

    const sortIcon = (field) => {
        if (greeksSortField !== field) return '';
        return greeksSortAsc ? ' ▲' : ' ▼';
    };

    const sortClass = (field) => {
        return greeksSortField === field ? 'sort-active' : '';
    };

    let html = `
        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th class="sortable ${sortClass('expiration')}" onclick="setGreeksSort('expiration')">Exp${sortIcon('expiration')}</th>
                        <th class="sortable ${sortClass('strike')}" onclick="setGreeksSort('strike')">Strike${sortIcon('strike')}</th>
                        <th class="sortable ${sortClass('dte')}" onclick="setGreeksSort('dte')">DTE${sortIcon('dte')}</th>
                        <th class="sortable number ${sortClass('close_price')}" onclick="setGreeksSort('close_price')">Price${sortIcon('close_price')}</th>
                        <th class="sortable number ${sortClass('delta')}" onclick="setGreeksSort('delta')">Delta${sortIcon('delta')}</th>
                        <th class="sortable number ${sortClass('gamma')}" onclick="setGreeksSort('gamma')">Gamma${sortIcon('gamma')}</th>
                        <th class="sortable number ${sortClass('theta')}" onclick="setGreeksSort('theta')">Theta${sortIcon('theta')}</th>
                        <th class="sortable number ${sortClass('vega')}" onclick="setGreeksSort('vega')">Vega${sortIcon('vega')}</th>
                        <th class="sortable number ${sortClass('implied_vol')}" onclick="setGreeksSort('implied_vol')">IV${sortIcon('implied_vol')}</th>
                        <th class="sortable number ${sortClass('volume_today')}" onclick="setGreeksSort('volume_today')">Vol${sortIcon('volume_today')}</th>
                        <th class="sortable number ${sortClass('open_interest')}" onclick="setGreeksSort('open_interest')">OI${sortIcon('open_interest')}</th>
                    </tr>
                </thead>
                <tbody>
    `;

    for (const row of sorted) {
        const deltaClass = row.delta !== null ? (row.delta > 0.5 ? 'positive' : row.delta < -0.5 ? 'negative' : '') : '';
        const thetaClass = row.theta !== null ? (row.theta < 0 ? 'negative' : '') : '';

        html += `
            <tr>
                <td><span class="exp-badge">${row.expiration || '-'}</span></td>
                <td>${row.strike}</td>
                <td>${row.dte}</td>
                <td class="number">${formatMoney(row.close_price)}</td>
                <td class="number ${deltaClass}">${row.delta !== null ? row.delta.toFixed(4) : '-'}</td>
                <td class="number">${row.gamma !== null ? row.gamma.toFixed(5) : '-'}</td>
                <td class="number ${thetaClass}">${row.theta !== null ? row.theta.toFixed(4) : '-'}</td>
                <td class="number">${row.vega !== null ? row.vega.toFixed(4) : '-'}</td>
                <td class="number">${row.implied_vol !== null ? (row.implied_vol * 100).toFixed(1) + '%' : '-'}</td>
                <td class="number">${formatNumber(row.volume_today)}</td>
                <td class="number">${formatNumber(row.open_interest)}</td>
            </tr>
        `;
    }

    html += '</tbody></table></div>';
    return html;
}

function renderGreeksCharts() {
    renderIVSmileChart();
    renderVolSurfaceChart();
}

function renderIVSmileChart() {
    const enrichedData = data.enriched.data || [];

    if (!enrichedData.length) {
        document.getElementById('ivSmileChart').innerHTML = '<div class="loading">No data available</div>';
        return;
    }

    // Get unique expirations
    const expirations = [...new Set(enrichedData.map(r => r.expiration))].sort();

    // If filtering by expiration, only show that one
    const expsToShow = selectedExpiration ? [selectedExpiration] : expirations.slice(0, 4);

    // IBKR-style muted colors for multiple expirations
    const expColors = [
        theme.primary,          // Red for nearest expiry
        theme.info,             // Blue
        theme.accentPurple,     // Purple
        theme.success           // Green
    ];

    const traces = [];

    for (let i = 0; i < expsToShow.length; i++) {
        const exp = expsToShow[i];
        const expData = enrichedData
            .filter(r => r.expiration === exp && r.implied_vol !== null)
            .sort((a, b) => a.strike - b.strike);

        if (expData.length < 2) continue;

        const strikes = expData.map(r => r.strike);
        const ivs = expData.map(r => (r.implied_vol * 100));
        const dte = expData[0]?.dte || '?';

        traces.push({
            x: strikes,
            y: ivs,
            type: 'scatter',
            mode: 'lines+markers',
            name: `${formatShortDate(exp)} (${dte}d)`,
            line: {
                color: expColors[i % expColors.length],
                width: 2,
                shape: 'spline',
                smoothing: 0.8
            },
            marker: {
                color: expColors[i % expColors.length],
                size: 5,
                line: { color: theme.bgSecondary, width: 1 }
            },
            hovertemplate: `<b>Strike: %{x}</b><br>IV: %{y:.1f}%<br>${formatShortDate(exp)}<extra></extra>`,
            hoverlabel: {
                bgcolor: theme.neutral5,
                bordercolor: theme.neutral30,
                font: { family: "'Source Sans Pro', Arial", size: 12, color: theme.fontColor }
            }
        });
    }

    if (!traces.length) {
        document.getElementById('ivSmileChart').innerHTML = '<div class="loading">No IV data available</div>';
        return;
    }

    // Get spot price for ATM reference
    const spotPrice = data.enriched.meta?.spot_price;

    // ATM reference line
    const atmShapes = spotPrice ? [{
        type: 'line',
        x0: spotPrice,
        x1: spotPrice,
        y0: 0,
        y1: 1,
        yref: 'paper',
        line: {
            color: theme.textMuted,
            width: 1,
            dash: 'dot'
        }
    }] : [];

    const atmAnnotations = spotPrice ? [{
        x: spotPrice,
        y: 1,
        yref: 'paper',
        text: `ATM ${spotPrice?.toLocaleString() || ''}`,
        showarrow: false,
        font: {
            family: "'Source Sans Pro', Arial",
            size: 10,
            color: theme.textMuted
        },
        yanchor: 'bottom',
        yshift: 4
    }] : [];

    Plotly.newPlot('ivSmileChart', traces, {
        ...plotlyLayout,
        title: {
            text: 'IV Smile by Expiration',
            font: { size: 13, color: theme.textSecondary },
            x: 0,
            xanchor: 'left'
        },
        xaxis: {
            ...plotlyLayout.xaxis,
            title: { text: 'Strike', font: { size: 11, color: theme.textMuted }, standoff: 6 }
        },
        yaxis: {
            ...plotlyLayout.yaxis,
            title: { text: 'IV (%)', font: { size: 11, color: theme.textMuted }, standoff: 6 }
        },
        legend: {
            ...plotlyLayout.legend,
            y: -0.18
        },
        shapes: atmShapes,
        annotations: atmAnnotations,
        margin: { t: 32, r: 12, b: 55, l: 48 }
    }, {
        ...plotlyConfig,
        displayModeBar: true,
        modeBarButtonsToRemove: ['lasso2d', 'select2d', 'autoScale2d'],
        displaylogo: false
    });
}

function renderVolSurfaceChart() {
    const enrichedData = data.enriched.data || [];

    if (!enrichedData.length) {
        document.getElementById('volSurfaceChart').innerHTML = '<div class="loading">No data available</div>';
        return;
    }

    // Filter to data with IV values
    const ivData = enrichedData.filter(r => r.implied_vol !== null);

    if (ivData.length < 3) {
        document.getElementById('volSurfaceChart').innerHTML = '<div class="loading">Insufficient IV data for surface</div>';
        return;
    }

    // Get unique sorted strikes and expirations (by DTE)
    const strikes = [...new Set(ivData.map(r => r.strike))].sort((a, b) => a - b);
    const expirations = [...new Set(ivData.map(r => r.expiration))].sort();

    // Build a map for quick lookup: expiration -> strike -> iv (as percentage)
    const ivMap = {};
    const allIVs = []; // Collect all IV values for stats
    for (const row of ivData) {
        if (!ivMap[row.expiration]) ivMap[row.expiration] = {};
        const ivPct = row.implied_vol * 100;
        ivMap[row.expiration][row.strike] = ivPct;
        allIVs.push(ivPct);
    }

    // Calculate mean and standard deviation for Z-score mode
    const mean = allIVs.reduce((a, b) => a + b, 0) / allIVs.length;
    const variance = allIVs.reduce((sum, iv) => sum + Math.pow(iv - mean, 2), 0) / allIVs.length;
    const stdDev = Math.sqrt(variance);

    // Get DTE for each expiration for Y-axis
    const dteMap = {};
    for (const row of ivData) {
        dteMap[row.expiration] = row.dte;
    }

    // Build Z matrix (rows = expirations, cols = strikes)
    // Use null for missing data points (Plotly will leave gaps)
    const z = [];
    const zRaw = []; // Keep raw values for hover text
    const y = []; // DTE values
    const yLabels = []; // Expiration labels for hover

    for (const exp of expirations) {
        const row = [];
        const rowRaw = [];
        for (const strike of strikes) {
            const iv = ivMap[exp]?.[strike];
            if (iv !== undefined) {
                rowRaw.push(iv);
                if (volSurfaceMode === 'zscore') {
                    // Transform to Z-score
                    row.push((iv - mean) / stdDev);
                } else {
                    row.push(iv);
                }
            } else {
                row.push(null);
                rowRaw.push(null);
            }
        }
        z.push(row);
        zRaw.push(rowRaw);
        y.push(dteMap[exp]);
        yLabels.push(exp);
    }

    // Create custom hover text
    const hoverText = z.map((row, i) =>
        row.map((val, j) => {
            if (val === null) return '';
            const rawIV = zRaw[i][j];
            if (volSurfaceMode === 'zscore') {
                const zScore = val;
                const anomalyLabel = Math.abs(zScore) >= 2 ? ' ⚠️ ANOMALY' : '';
                return `Strike: ${strikes[j]}<br>DTE: ${y[i]}d (${formatShortDate(yLabels[i])})<br>IV: ${rawIV.toFixed(1)}%<br>Z-Score: ${zScore >= 0 ? '+' : ''}${zScore.toFixed(2)}σ${anomalyLabel}`;
            } else {
                return `Strike: ${strikes[j]}<br>DTE: ${y[i]}d (${formatShortDate(yLabels[i])})<br>IV: ${rawIV.toFixed(1)}%`;
            }
        })
    );

    // Colorscales for different modes
    const rawColorscale = [
        [0, '#1e3a5f'],           // Low IV - deep blue
        [0.2, '#2563a8'],         // Blue
        [0.4, theme.info],        // Info blue
        [0.5, '#4a8a6a'],         // Teal transition
        [0.6, theme.success],     // Green
        [0.75, theme.warning],    // Amber
        [0.9, '#c45a28'],         // Orange
        [1, theme.primary]        // High IV - red
    ];

    // Diverging colorscale for Z-score: blue (cheap) -> gray (normal) -> red (expensive)
    const zscoreColorscale = [
        [0, '#1e5a9e'],           // Very cheap (-3σ) - deep blue
        [0.17, '#3b82c4'],        // -2σ - blue
        [0.33, '#6a9bc4'],        // -1σ - light blue
        [0.5, theme.neutral30],   // 0σ - neutral gray
        [0.67, '#c49a6a'],        // +1σ - light amber
        [0.83, '#c45a28'],        // +2σ - orange
        [1, '#b33a3a']            // Very expensive (+3σ) - red
    ];

    const colorscale = volSurfaceMode === 'zscore' ? zscoreColorscale : rawColorscale;

    // For Z-score mode, center the color scale at 0 and cap at ±3σ
    const zMin = volSurfaceMode === 'zscore' ? -3 : undefined;
    const zMax = volSurfaceMode === 'zscore' ? 3 : undefined;
    const zMid = volSurfaceMode === 'zscore' ? 0 : undefined;

    // Colorbar config based on mode
    const colorbarConfig = volSurfaceMode === 'zscore' ? {
        title: {
            text: 'Z-Score (σ)',
            font: { family: "'Source Sans Pro', Arial", size: 10, color: theme.textMuted },
            side: 'right'
        },
        tickfont: { family: "'Source Sans Pro', Arial", size: 9, color: theme.textMuted },
        len: 0.6,
        thickness: 12,
        xpad: 8,
        ticksuffix: 'σ',
        outlinecolor: theme.border,
        outlinewidth: 1
    } : {
        title: {
            text: 'IV %',
            font: { family: "'Source Sans Pro', Arial", size: 10, color: theme.textMuted },
            side: 'right'
        },
        tickfont: { family: "'Source Sans Pro', Arial", size: 9, color: theme.textMuted },
        len: 0.6,
        thickness: 12,
        xpad: 8,
        ticksuffix: '%',
        outlinecolor: theme.border,
        outlinewidth: 1
    };

    // Z-axis label based on mode
    const zAxisTitle = volSurfaceMode === 'zscore' ? 'Z-Score (σ)' : 'IV %';

    // Adjust aspect ratio for Z-score mode to amplify peaks/troughs
    const aspectRatio = volSurfaceMode === 'zscore'
        ? { x: 1.2, y: 1, z: 1.0 }  // Taller Z for Z-score
        : { x: 1.2, y: 1, z: 0.7 };  // Flatter for raw

    Plotly.newPlot('volSurfaceChart', [{
        type: 'surface',
        x: strikes,
        y: y,
        z: z,
        colorscale: colorscale,
        cmin: zMin,
        cmax: zMax,
        cmid: zMid,
        hoverinfo: 'text',
        text: hoverText,
        hoverlabel: {
            bgcolor: theme.neutral5,
            bordercolor: theme.neutral30,
            font: { family: "'Source Sans Pro', Arial", size: 12, color: theme.fontColor }
        },
        contours: {
            z: {
                show: true,
                usecolormap: true,
                highlightcolor: theme.fontColorDark,
                project: { z: false }
            }
        },
        colorbar: colorbarConfig,
        lighting: {
            ambient: 0.8,
            diffuse: 0.5,
            specular: 0.2,
            roughness: 0.5
        },
        connectgaps: false  // Don't interpolate missing data
    }], {
        paper_bgcolor: theme.bgSecondary,
        plot_bgcolor: theme.bgSecondary,
        font: {
            color: theme.fontColor,
            family: "'Source Sans Pro', Arial",
            size: 10
        },
        scene: {
            xaxis: {
                title: { text: 'Strike', font: { size: 10, color: theme.textMuted } },
                gridcolor: theme.neutral20,
                showbackground: true,
                backgroundcolor: theme.bgDarkest,
                tickfont: { size: 9, color: theme.textMuted }
            },
            yaxis: {
                title: { text: 'DTE', font: { size: 10, color: theme.textMuted } },
                gridcolor: theme.neutral20,
                showbackground: true,
                backgroundcolor: theme.bgDarkest,
                tickfont: { size: 9, color: theme.textMuted }
            },
            zaxis: {
                title: { text: zAxisTitle, font: { size: 10, color: theme.textMuted } },
                gridcolor: theme.neutral20,
                showbackground: true,
                backgroundcolor: theme.bgDarkest,
                tickfont: { size: 9, color: theme.textMuted }
            },
            camera: {
                eye: { x: 1.5, y: -1.5, z: 0.8 },
                center: { x: 0, y: 0, z: -0.1 }
            },
            aspectmode: 'manual',
            aspectratio: aspectRatio
        },
        margin: { t: 10, r: 10, b: 10, l: 10 }
    }, {
        responsive: true,
        displayModeBar: true,
        modeBarButtonsToRemove: ['toImage', 'sendDataToCloud'],
        displaylogo: false
    });
}

// Initial load
loadAll();

// Auto-refresh every 60 seconds
setInterval(loadAll, 60000);
